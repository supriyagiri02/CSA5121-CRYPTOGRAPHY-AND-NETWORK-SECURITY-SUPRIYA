# Demonstrating the DES Subkey Property:
# First 24 bits of each subkey come ONLY from C (left 28 bits)
# Last 24 bits come ONLY from D (right 28 bits)

PC1 = [
    57,49,41,33,25,17,9,
    1,58,50,42,34,26,18,
    10,2,59,51,43,35,27,
    19,11,3,60,52,44,36,
    63,55,47,39,31,23,15,
    7,62,54,46,38,30,22,
    14,6,61,53,45,37,29,
    21,13,5,28,20,12,4
]

PC2 = [
    14,17,11,24,1,5,
    3,28,15,6,21,10,
    23,19,12,4,26,8,
    16,7,27,20,13,2,
    41,52,31,37,47,55,
    30,40,51,45,33,48,
    44,49,39,56,34,53,
    46,42,50,36,29,32
]

SHIFT_SCHEDULE = [
    1,1,2,2,2,2,2,2,
    1,2,2,2,2,2,2,1
]

def permute(block, table):
    return ''.join(block[i-1] for i in table)

def left_shift(bits, n):
    return bits[n:] + bits[:n]

def generate_keys(key64):
    key56 = permute(key64, PC1)
    C, D = key56[:28], key56[28:]

    subkeys = []
    for shift in SHIFT_SCHEDULE:
        C = left_shift(C, shift)
        D = left_shift(D, shift)
        CD = C + D
        K = permute(CD, PC2)
        subkeys.append((K, C, D))

    return subkeys

def analyze_subkey(K, C, D):
    c_positions = []
    d_positions = []

    for i, bit_index in enumerate(PC2, start=1):
        if bit_index <= 28:
            c_positions.append(i)
        else:
            d_positions.append(i)

    return c_positions, d_positions


# MAIN
if __name__ == "__main__":
    key64 = "0001001100110100010101110111100110011011101111001101111111110001"

    subkeys = generate_keys(key64)

    for r, (K, C, D) in enumerate(subkeys, start=1):
        cpos, dpos = analyze_subkey(K, C, D)

        print(f"\nROUND {r}:")
        print("Subkey (48 bits):", K)
        print("C contributes to Positions:", cpos)
        print("D contributes to Positions:", dpos)

        # Verify property
        if len(cpos) == 24 and len(dpos) == 24:
            print("✓ First 24 bits from C, next 24 from D (property holds!)")
        else:
            print("✗ Property does NOT hold!")
